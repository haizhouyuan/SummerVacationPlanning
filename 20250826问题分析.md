问题一：任务时间轴刷新后任务内容/状态变动

现象：在任务时间轴页面刷新后，页面上显示的任务列表及其状态发生变化，与刷新前不一致。

原因分析：

前端请求参数错误：前端在加载每日任务时未正确传递日期过滤参数，导致每次刷新获取的任务集不稳定。TaskSchedule组件中调用apiService.getDailyTasks时直接传入日期字符串而非对象，未正确生成查询参数。例如，调用 getDailyTasks("2025-08-26") 未附加 date 参数，导致后端返回所有任务而非指定日期任务。这会使时间轴每次刷新获取到的任务列表可能包含其它日期的任务，顺序和状态紊乱。

数据字段类型不一致：后端getDailyTasks接口按查询参数date过滤。由于创建每日任务时将日期字段转换为Date对象保存（验证规则.toDate()将字符串转为JS Date），数据库中的date为Date类型。但查询时直接用字符串比较，类型不匹配导致过滤失效。结果是即使传了日期参数也可能查询不到当日任务，或返回全部任务集合。

演示模式随机任务：系统的兼容模式可能错误触发，返回演示数据。detectNetworkAndGetApiServiceSync中，如果检测到某些条件（如邮箱包含中文或特殊标记）将强制使用compatibleApiService。演示模式下每日任务通过getMockDailyTasks生成，其中过去数日任务随机模拟。一旦前端误走入演示模式，每次刷新都会重新生成任务数据，导致时间轴任务看似随机变化。这属于前端状态未正确绑定真实数据源的问题。

任务状态未持久化：检查代码确认任务完成/更新操作已调用后端接口并持久化状态。例如updateDailyTaskStatus将任务状态更新写入数据库，并根据证据设置approvalStatus。如果时间轴刷新后任务状态异常变化，可能是前端加载的任务集不对（如上所述过滤问题），而非状态本身未保存。

涉及代码路径：

前端加载任务：frontend/src/pages/TaskSchedule.tsx 的 loadDailyTasks 方法，调用 apiService.getDailyTasks(date)。

前端正确示例：frontend/src/pages/TodayTasks.tsx 使用 { date: todayDate } 对象传参，生成正确查询参数。

后端接口：backend/src/controllers/dailyTaskController.ts 的 getDailyTasks，依赖 req.query.date 过滤。

数据模型：backend/src/controllers/dailyTaskController.ts 的 createDailyTask 将 req.body.date 转为 Date 存库。

改进建议：

前端请求修正：将时间轴页面的每日任务请求改为传递对象参数。例如：

apiService.getDailyTasks({ date: selectedDate })

确保URL包含?date=YYYY-MM-DD查询参数，限定返回当天任务。同时移除TaskTimeline独立组件重复逻辑，统一由父组件控制刷新，避免状态不同步。

统一日期类型：后端应统一每日任务的日期字段类型和过滤逻辑。可选方案：

方案A：存储为字符串（YYYY-MM-DD），便于直接按字符串匹配。需在创建任务时用toISOString().split('T')[0]格式化日期字符串入库，并在查询前将req.query.date值标准化处理。

方案B：存储为Date类型，但查询时将字符串参数转换为Date范围。例如，将date=2025-08-26转换为查询条件 date >= 2025-08-26T00:00:00 && < 2025-08-27T00:00:00。
确保前后端对日期的一致处理，消除因类型不匹配导致的任务漏查或误查。

防演示模式误用：优化detectNetworkAndGetApiServiceSync的判断逻辑。避免因用户邮箱或本地缓存误判为演示模式。例如，去除对中文邮箱的强制demo判断，改用显式开关控制。确保正式部署下始终使用真实API，以免返回mock随机任务。

前端状态绑定：在React状态管理上，不要依赖刷新页面获取正确数据，而应在任务操作后及时更新UI状态。当前代码在拖拽、调整任务时调用onRefresh重新加载任务。应检查onRefresh实现是否可靠触发数据刷新，以及在组件卸载或切换视图时清理旧状态，避免残留数据造成下一次渲染混乱。

问题二：兑换成功提示但总积分未变化

现象：用户进行积分兑换后，前端弹出“兑换成功”的提示，但用户总积分并未减少。此问题在“游戏时间兑换”和“特殊奖励兑换”两种场景下出现。

原因分析：

后端积分扣减逻辑：后端实际有扣分操作，但可能未及时反映到前端：

游戏时间兑换：在exchangeGameTime接口中，使用事务原子扣减用户积分并记录兑换。兑换成功响应也返回了新的积分余额newPointsBalance。

特殊奖励兑换：学生请求特殊奖励时(requestSpecialReward)未立即扣分，仅创建了待审批记录。积分扣除延后到家长审批通过时，在approveSpecialRedemption中扣减。审批通过响应返回扣除积分数和学生新余额。

后端逻辑表明游戏时间兑换即时扣积分、特殊奖励兑换暂不扣积分（等待审批）。因此，如果后端事务正常提交，问题可能出在前端状态更新。

前端用户状态未更新：前端在兑换成功后调用了refreshUser()试图刷新用户信息。然而AuthContext中refreshUser并未从真实后端获取最新用户，而是调用兼容服务读取本地缓存。在当前实现下，compatibleAuthService.getProfile()直接返回登录时缓存在localStorage的用户快照（演示数据），其中积分是固定值（例如150分）。它并不知道后端最新扣分结果。

对于游戏时间兑换：后端虽扣除了积分，但前端refreshUser()仍然把用户积分重置为旧值（例如150不变），因此页面上看不到减少。

对于特殊奖励兑换：提交请求成功后，前端同样没有减少用户积分，因为本就未扣分且refreshUser()未改变任何状态。用户会看到积分未变，但这实际上是符合逻辑的（待审批前不扣分）。只是前端提示用词可能引起误解，将“提交成功”误认为“兑换成功”。

缺少冻结/预扣机制：系统未实现pendingPoints字段或冻结机制来锁定待审批积分。这意味着学生在等待家长审批期间，其账户积分仍可自由使用。如果此间积分不足，家长审批时将失败。目前的实现仅在审批时再次验证积分是否充足并扣减。这种设计会导致前端提示和实际扣分存在时间差。

涉及代码路径：

前端兑换流程：frontend/src/components/GameTimeExchange.tsx 的 handleExchange 方法，在调用兑换接口后执行refreshUser()和成功提示。

前端用户刷新：frontend/src/contexts/AuthContext.tsx 中的 refreshUser 调用compatibleAuthService.getProfile，后者返回本地缓存的用户信息（始终150积分等演示值）。

后端游戏时间兑换：backend/src/controllers/rewardsController.ts 的 exchangeGameTime，包含用户积分扣减事务。

后端特殊奖励请求/审批：backend/src/controllers/rewardsController.ts 的 requestSpecialReward插入请求但不扣分；approveSpecialRedemption审批时扣减积分。

改进建议：

刷新用户数据源改为真实API：前端AuthContext应在可能时使用真实后端接口获取用户最新状态，而非始终走本地兼容模式。可以引入条件：当检测到网络正常且有权限调用/auth/profile时，refreshUser()改用真实mongoAuthService.getProfile()来获取用户当前积分等信息，然后更新上下文。这将确保兑换扣分后的最新积分同步到前端。

即时更新本地积分：作为补充，即使不更换数据源，前端在收到兑换成功响应时也可直接根据已知扣分额度更新本地用户状态。例如游戏时间兑换成功后，利用后端响应中的newPointsBalance或已知扣分值，主动更新user.points。特殊奖励请求提交后，可暂时从UI减去pointsCost并标记冻结（例如灰掉积分或显示“待扣除”提示），待审批结果再调整。这样前端反馈会更及时。

改进用户提示：区分“兑换请求提交成功”和实际“兑换完成”的概念。对于特殊奖励，应在前端提示中明确“奖励申请已提交，待家长审批后扣除积分”而不是简单提示兑换成功，以防用户误解积分未变动是错误。在游戏时间兑换完成后，确保提示和界面显示的新积分余额一致，增强信任。

增加冻结积分机制（可选）：为了防止多重消费问题，可在specialRewardRequests记录中增加一个冻结标记，并考虑立即冻结相应积分。例如，在学生提交奖励申请时扣减或冻结积分（在用户表新增pendingPoints字段或减少可用积分），审批通过则正式扣除，拒绝则返还积分。这需要调整后端逻辑，但能保证前端积分变化与操作更同步，并避免期间重复使用积分的风险。

最小测试用例集

为验证上述问题的修复和系统稳定性，设计以下关键测试用例：

用例1：时间轴任务一致性 – 创建若干当天任务（含不同状态，如planned、completed），记录预期列表。刷新“任务日程”页面多次，核对任务列表内容和状态是否与预期一致且无异常变动。特别验证切换日期过滤（如选择昨天、今天）时，仅显示对应日期任务。

用例2：任务状态持久化 – 将某任务拖拽调整时间或标记完成后立即刷新页面，确认该任务的新时间或完成状态仍然正确显示。避免出现操作后刷新状态反复的情况。

用例3：游戏时间兑换扣分 – 假设用户当前有100积分，兑换10积分的普通游戏时间。预期后端扣分后用户剩余90。操作后检查：

前端弹出成功提示显示兑换分钟数正确，例如“获得50分钟普通游戏时间”。

前端用户积分显示从100减至90。

数据库中该用户积分字段确已减为90，且gameTimeExchanges集合新增一条记录pointsSpent=10。

用例4：特殊奖励兑换流程 – 用户有50积分，申请一个需要30积分的特殊奖励：

提交申请后，前端提示“申请已提交，待审批”，用户积分仍显示50但可能标注30积分待扣除。

登录家长账号审批通过请求。审批成功后，验证学生端积分立即减少30（应更新为20）。

如家长拒绝请求，学生积分仍维持50不变，无扣分发生。

若学生在等待审批期间将积分花掉（如兑换游戏时间导致余额不足30），家长审批应失败并给出错误，这也需测试。

用例5：演示模式隔离 – 切换系统至非演示正式模式，重复上述兑换操作，确认refreshUser拉取真实数据，积分更新正常。再模拟演示模式（设置isDemo=true），操作兑换仅影响演示数据、不改动真实数据库，且不会污染正式模式下的数据读取。

通过以上测试，确保任务刷新和积分扣除逻辑在修复后稳定一致，前后端状态同步，用户体验正确无误。

代码路径摘要：本报告涉及的主要代码文件和行号如下：

前端任务日程加载：TaskSchedule.tsx 中 loadDailyTasks 调用。

前端今日任务页：TodayTasks.tsx 中正确的日期过滤示例及任务完成后刷新逻辑。

后端每日任务控制器：dailyTaskController.ts 中 getDailyTasks 查询与 createDailyTask 存储。

前端兑换组件：GameTimeExchange.tsx 中兑换提交与用户刷新。

前端认证上下文：AuthContext.tsx 与 compatibleAuth.ts 中的 refreshUser 实现。

后端兑换控制器：rewardsController.ts 中游戏时间兑换、特殊奖励请求与审批。

以上代码佐证了问题成因与改进方向，结合测试用例可验证修复效果，确保系统积分逻辑的正确性和用户界面的一致性。