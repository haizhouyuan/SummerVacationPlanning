/**
 * ÈîôËØØÂ§ÑÁêÜÁ≥ªÁªüÂçïÂÖÉÊµãËØï
 * ÊµãËØïÊï∞ÊçÆÁä∂ÊÄÅÁÆ°ÁêÜ„ÄÅÈîôËØØÁä∂ÊÄÅ„ÄÅÂä†ËΩΩÁä∂ÊÄÅ„ÄÅÈáçËØïÊú∫Âà∂Á≠â
 */

import React from 'react';
import { render, screen, waitFor, act } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

import {
  createInitialDataState,
  setLoadingState,
  setErrorState,
  setDataState,
  LoadingSpinner,
  ErrorDisplay,
  useDataState,
  withRetry,
  ErrorType,
} from '../errorHandling';

describe('ErrorHandling System Tests', () => {
  describe('Êï∞ÊçÆÁä∂ÊÄÅÁÆ°ÁêÜ', () => {
    it('createInitialDataStateÂ∫îËØ•ËøîÂõûÂàùÂßãÁä∂ÊÄÅ', () => {
      const initialState = createInitialDataState();
      
      expect(initialState).toEqual({
        data: null,
        loading: {
          isLoading: false,
        },
        error: {
          hasError: false,
          canRetry: true,
        },
      });
    });

    it('createInitialDataStateÂ∫îËØ•Êé•ÂèóÂàùÂßãÊï∞ÊçÆ', () => {
      const initialData = { test: 'data' };
      const initialState = createInitialDataState(initialData);
      
      expect(initialState.data).toEqual(initialData);
    });

    it('setLoadingStateÂ∫îËØ•Êõ¥Êñ∞Âä†ËΩΩÁä∂ÊÄÅÂπ∂Ê∏ÖÈô§ÈîôËØØ', () => {
      const initialState = createInitialDataState();
      const errorState = setErrorState(initialState, {
        error: 'Previous error',
        context: 'test',
      });
      
      const loadingState = setLoadingState(errorState, {
        isLoading: true,
        loadingMessage: 'Loading...',
      });
      
      expect(loadingState.loading).toEqual({
        isLoading: true,
        loadingMessage: 'Loading...',
      });
      expect(loadingState.error.hasError).toBe(false);
    });

    it('setErrorStateÂ∫îËØ•Êõ¥Êñ∞ÈîôËØØÁä∂ÊÄÅÂπ∂ÂÅúÊ≠¢Âä†ËΩΩ', () => {
      const initialState = createInitialDataState();
      const loadingState = setLoadingState(initialState, { isLoading: true });
      
      const errorState = setErrorState(loadingState, {
        error: 'Test error',
        context: 'testing',
        errorCode: 'TEST_ERROR',
      });
      
      expect(errorState.loading.isLoading).toBe(false);
      expect(errorState.error).toEqual({
        hasError: true,
        error: 'Test error',
        context: 'testing',
        errorCode: 'TEST_ERROR',
        canRetry: true,
      });
    });

    it('setDataStateÂ∫îËØ•Êõ¥Êñ∞Êï∞ÊçÆÂπ∂Ê∏ÖÈô§Âä†ËΩΩÂíåÈîôËØØÁä∂ÊÄÅ', () => {
      const initialState = createInitialDataState();
      const loadingState = setLoadingState(initialState, { isLoading: true });
      const errorState = setErrorState(loadingState, { error: 'Error' });
      
      const testData = { result: 'success' };
      const dataState = setDataState(errorState, testData);
      
      expect(dataState.data).toEqual(testData);
      expect(dataState.loading.isLoading).toBe(false);
      expect(dataState.error.hasError).toBe(false);
      expect(dataState.lastUpdated).toBeInstanceOf(Date);
    });
  });

  describe('useDataState Hook', () => {
    const TestComponent: React.FC<{ initialData?: any }> = ({ initialData }) => {
      const dataState = useDataState(initialData);
      
      return (
        <div>
          <div data-testid="loading">{dataState.loading.isLoading.toString()}</div>
          <div data-testid="error">{dataState.error.hasError.toString()}</div>
          <div data-testid="data">{JSON.stringify(dataState.data)}</div>
          <button 
            data-testid="set-loading" 
            onClick={() => dataState.setLoading({ isLoading: true, loadingMessage: 'Loading...' })}
          >
            Set Loading
          </button>
          <button 
            data-testid="set-error" 
            onClick={() => dataState.setError(new Error('Test error'), 'test')}
          >
            Set Error
          </button>
          <button 
            data-testid="set-data" 
            onClick={() => dataState.setData({ test: 'data' })}
          >
            Set Data
          </button>
        </div>
      );
    };

    it('Â∫îËØ•ÂàùÂßãÂåñ‰∏∫ÈªòËÆ§Áä∂ÊÄÅ', () => {
      render(<TestComponent />);
      
      expect(screen.getByTestId('loading')).toHaveTextContent('false');
      expect(screen.getByTestId('error')).toHaveTextContent('false');
      expect(screen.getByTestId('data')).toHaveTextContent('null');
    });

    it('Â∫îËØ•Ê≠£Á°ÆÊõ¥Êñ∞Âä†ËΩΩÁä∂ÊÄÅ', async () => {
      const user = userEvent.setup();
      render(<TestComponent />);
      
      await user.click(screen.getByTestId('set-loading'));
      
      expect(screen.getByTestId('loading')).toHaveTextContent('true');
    });

    it('Â∫îËØ•Ê≠£Á°ÆÊõ¥Êñ∞ÈîôËØØÁä∂ÊÄÅ', async () => {
      const user = userEvent.setup();
      render(<TestComponent />);
      
      await user.click(screen.getByTestId('set-error'));
      
      expect(screen.getByTestId('error')).toHaveTextContent('true');
      expect(screen.getByTestId('loading')).toHaveTextContent('false');
    });

    it('Â∫îËØ•Ê≠£Á°ÆÊõ¥Êñ∞Êï∞ÊçÆÁä∂ÊÄÅ', async () => {
      const user = userEvent.setup();
      render(<TestComponent />);
      
      await user.click(screen.getByTestId('set-data'));
      
      expect(screen.getByTestId('data')).toHaveTextContent('{"test":"data"}');
      expect(screen.getByTestId('loading')).toHaveTextContent('false');
      expect(screen.getByTestId('error')).toHaveTextContent('false');
    });

    it('Â∫îËØ•Êé•ÂèóÂàùÂßãÊï∞ÊçÆ', () => {
      const initialData = { initial: 'test' };
      render(<TestComponent initialData={initialData} />);
      
      expect(screen.getByTestId('data')).toHaveTextContent('{"initial":"test"}');
    });
  });

  describe('LoadingSpinnerÁªÑ‰ª∂', () => {
    it('Â∫îËØ•ÊòæÁ§∫ÈªòËÆ§Âä†ËΩΩÊ∂àÊÅØ', () => {
      render(<LoadingSpinner />);
      expect(screen.getByText('Âä†ËΩΩ‰∏≠...')).toBeInTheDocument();
    });

    it('Â∫îËØ•ÊòæÁ§∫Ëá™ÂÆö‰πâÊ∂àÊÅØ', () => {
      render(<LoadingSpinner message="Ê≠£Âú®Â§ÑÁêÜ..." />);
      expect(screen.getByText('Ê≠£Âú®Â§ÑÁêÜ...')).toBeInTheDocument();
    });

    it('Â∫îËØ•ÊòæÁ§∫ËøõÂ∫¶Êù°ÂΩìÊúâËøõÂ∫¶ÂÄºÊó∂', () => {
      render(<LoadingSpinner progress={50} />);
      expect(screen.getByRole('progressbar')).toHaveAttribute('aria-valuenow', '50');
    });

    it('Â∫îËØ•Â∫îÁî®Ëá™ÂÆö‰πâÊ†∑ÂºèÁ±ª', () => {
      render(<LoadingSpinner className="custom-class" />);
      expect(screen.getByTestId('loading-spinner')).toHaveClass('custom-class');
    });

    it('Â∫îËØ•ÊîØÊåÅ‰∏çÂêåÂ∞∫ÂØ∏', () => {
      const { rerender } = render(<LoadingSpinner size="sm" />);
      expect(screen.getByTestId('spinner-icon')).toHaveClass('w-4', 'h-4');
      
      rerender(<LoadingSpinner size="lg" />);
      expect(screen.getByTestId('spinner-icon')).toHaveClass('w-8', 'h-8');
    });
  });

  describe('ErrorDisplayÁªÑ‰ª∂', () => {
    const mockErrorState = {
      hasError: true,
      error: new Error('Test error message'),
      context: 'testing',
      canRetry: true,
      retryAction: jest.fn(),
    };

    beforeEach(() => {
      jest.clearAllMocks();
    });

    it('Â∫îËØ•ÊòæÁ§∫ÈîôËØØÊ∂àÊÅØ', () => {
      const errorState = { ...mockErrorState };
      render(<ErrorDisplay error={errorState} />);
      
      expect(screen.getByText(/Test error message/)).toBeInTheDocument();
    });

    it('Â∫îËØ•ÊòæÁ§∫ÈáçËØïÊåâÈíÆÂΩìcanRetry‰∏∫trueÊó∂', () => {
      const errorState = { ...mockErrorState };
      render(<ErrorDisplay error={errorState} />);
      
      expect(screen.getByText('ÈáçËØï')).toBeInTheDocument();
    });

    it('Â∫îËØ•ÈöêËóèÈáçËØïÊåâÈíÆÂΩìcanRetry‰∏∫falseÊó∂', () => {
      const errorState = { ...mockErrorState, canRetry: false };
      render(<ErrorDisplay error={errorState} />);
      
      expect(screen.queryByText('ÈáçËØï')).not.toBeInTheDocument();
    });

    it('Â∫îËØ•Ë∞ÉÁî®ÈáçËØïÂáΩÊï∞ÂΩìÁÇπÂáªÈáçËØïÊåâÈíÆÊó∂', async () => {
      const user = userEvent.setup();
      const errorState = { ...mockErrorState };
      render(<ErrorDisplay error={errorState} />);
      
      await user.click(screen.getByText('ÈáçËØï'));
      
      expect(errorState.retryAction).toHaveBeenCalledTimes(1);
    });

    it('Â∫îËØ•ÊòæÁ§∫‰∏ä‰∏ãÊñá‰ø°ÊÅØ', () => {
      const errorState = { ...mockErrorState };
      render(<ErrorDisplay error={errorState} />);
      
      expect(screen.getByText(/testing/)).toBeInTheDocument();
    });

    it('Â∫îËØ•Ê†πÊçÆÈîôËØØÁ±ªÂûãÊòæÁ§∫‰∏çÂêåÂõæÊ†á', () => {
      const networkErrorState = { ...mockErrorState, errorCode: ErrorType.NETWORK_ERROR };
      const { rerender } = render(<ErrorDisplay error={networkErrorState} />);
      expect(screen.getByText('üåê')).toBeInTheDocument();
      
      const authErrorState = { ...mockErrorState, errorCode: ErrorType.AUTHENTICATION_ERROR };
      rerender(<ErrorDisplay error={authErrorState} />);
      expect(screen.getByText('üîí')).toBeInTheDocument();
    });

    it('Â∫îËØ•ÊîØÊåÅ‰∏çÂêåÂ∞∫ÂØ∏', () => {
      const errorState = { ...mockErrorState };
      render(<ErrorDisplay error={errorState} size="lg" />);
      
      expect(screen.getByTestId('error-display')).toHaveClass('p-6');
    });
  });

  describe('withRetryÂáΩÊï∞', () => {
    let mockFn: jest.Mock;

    beforeEach(() => {
      mockFn = jest.fn();
    });

    it('Â∫îËØ•Âú®ÊàêÂäüÊó∂ËøîÂõûÁªìÊûú', async () => {
      mockFn.mockResolvedValue('success');
      
      const result = await withRetry(mockFn);
      
      expect(result).toBe('success');
      expect(mockFn).toHaveBeenCalledTimes(1);
    });

    it('Â∫îËØ•Âú®Â§±Ë¥•Êó∂ÈáçËØï', async () => {
      mockFn
        .mockRejectedValueOnce(new Error('First failure'))
        .mockRejectedValueOnce(new Error('Second failure'))
        .mockResolvedValue('success');
      
      const result = await withRetry(mockFn, {
        maxRetries: 3,
        baseDelay: 10,
      });
      
      expect(result).toBe('success');
      expect(mockFn).toHaveBeenCalledTimes(3);
    });

    it('Â∫îËØ•Âú®ËææÂà∞ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞ÂêéÊäõÂá∫ÈîôËØØ', async () => {
      mockFn.mockRejectedValue(new Error('Persistent error'));
      
      await expect(withRetry(mockFn, {
        maxRetries: 2,
        baseDelay: 10,
      })).rejects.toThrow('Persistent error');
      
      expect(mockFn).toHaveBeenCalledTimes(3); // 1 + 2 retries
    });

    it('Â∫îËØ•Ë∞ÉÁî®onRetryÂõûË∞É', async () => {
      const onRetry = jest.fn();
      mockFn
        .mockRejectedValueOnce(new Error('First failure'))
        .mockResolvedValue('success');
      
      await withRetry(mockFn, {
        maxRetries: 2,
        baseDelay: 10,
        onRetry,
      });
      
      expect(onRetry).toHaveBeenCalledWith(1, expect.any(Error));
    });

    it('Â∫îËØ•Â∫îÁî®ÊåáÊï∞ÈÄÄÈÅøÂª∂Ëøü', async () => {
      mockFn
        .mockRejectedValueOnce(new Error('First failure'))
        .mockResolvedValue('success');
      
      const startTime = Date.now();
      
      await withRetry(mockFn, {
        maxRetries: 1,
        baseDelay: 50,
        exponentialBackoff: true,
      });
      
      const endTime = Date.now();
      const duration = endTime - startTime;
      
      // Â∫îËØ•Ëá≥Â∞ëÁ≠âÂæÖbaseDelayÁöÑÊó∂Èó¥
      expect(duration).toBeGreaterThan(45);
    });

    it('Â∫îËØ•ÊîØÊåÅÊù°‰ª∂ÈáçËØï', async () => {
      const networkError = new Error('Network error');
      const authError = new Error('Authentication error');
      
      mockFn
        .mockRejectedValueOnce(networkError)
        .mockRejectedValueOnce(authError);
      
      const shouldRetry = (error: Error) => error.message.includes('Network');
      
      // ÁΩëÁªúÈîôËØØÂ∫îËØ•ÈáçËØï
      const result1 = await withRetry(mockFn, {
        maxRetries: 1,
        baseDelay: 10,
        shouldRetry,
      });
      
      expect(mockFn).toHaveBeenCalledTimes(2);
      
      // ËÆ§ËØÅÈîôËØØ‰∏çÂ∫îËØ•ÈáçËØï
      mockFn.mockClear();
      mockFn.mockRejectedValue(authError);
      
      await expect(withRetry(mockFn, {
        maxRetries: 1,
        baseDelay: 10,
        shouldRetry,
      })).rejects.toThrow('Authentication error');
      
      expect(mockFn).toHaveBeenCalledTimes(1); // ‰∏çÈáçËØï
    });
  });

  describe('ÈîôËØØÁ±ªÂûãÂàÜÁ±ª', () => {
    it('Â∫îËØ•Ê≠£Á°ÆÂàÜÁ±ªÁΩëÁªúÈîôËØØ', () => {
      const networkErrors = [
        'fetch failed',
        'Network request failed',
        'connection timeout',
      ];
      
      networkErrors.forEach(message => {
        const error = new Error(message);
        // ËøôÈáåÂÅáËÆæÊúâ‰∏Ä‰∏™ÂáΩÊï∞Êù•ÂàÜÁ±ªÈîôËØØÁ±ªÂûã
        // const type = classifyError(error);
        // expect(type).toBe(ErrorType.NETWORK_ERROR);
      });
    });
  });

  describe('ÊÄßËÉΩÂíåÂÜÖÂ≠òÊµãËØï', () => {
    it('Â∫îËØ•Ê≠£Á°ÆÊ∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨Âô®', () => {
      const { unmount } = render(<LoadingSpinner />);
      
      // Á°Æ‰øùÁªÑ‰ª∂ÂèØ‰ª•Ê≠£Â∏∏Âç∏ËΩΩÔºå‰∏ç‰ºöÈÄ†ÊàêÂÜÖÂ≠òÊ≥ÑÊºè
      expect(() => unmount()).not.toThrow();
    });

    it('Â∫îËØ•Â§ÑÁêÜÂ§ßÈáèÈîôËØØÁä∂ÊÄÅÊõ¥Êñ∞', () => {
      const TestComponent = () => {
        const dataState = useDataState();
        
        React.useEffect(() => {
          // Ê®°ÊãüÂ§ßÈáèÁä∂ÊÄÅÊõ¥Êñ∞
          for (let i = 0; i < 100; i++) {
            dataState.setError(new Error(`Error ${i}`), `context-${i}`);
          }
        }, []);
        
        return <div>{dataState.error.hasError.toString()}</div>;
      };
      
      expect(() => render(<TestComponent />)).not.toThrow();
    });
  });
});